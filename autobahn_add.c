#include "autobahn.h"

/**
 * @brief Perform binary addition (__adc) on words with carry.
 * 
 * This function performs binary addition on two words 'x' and 'y' along with
 * an incoming carry 'c'. It calculates the sum 'z' of 'x', 'y', and 'c' such
 * that: z = x + y + c. The result 'z' is stored in the variable pointed to by 'z',
 * and the carry 'c' is updated accordingly for the next addition operation.
 * 
 * @param z Pointer to a bi_uword where the result of the addition will be stored.
 * @param c Pointer to a bi_uword representing the incoming carry. The carry 'c' is
 *          updated to the carry generated by the addition operation.
 * @param x Pointer to a bi_uword representing the first operand 'x'.
 * @param y Pointer to a bi_uword representing the second operand 'y'.
 * 
 * @note
 * - The addition is performed modulo 2^(WORDSIZE*8), where WORDSIZE is the size of
 *   a word in bytes. This ensures that the result 'z' does not overflow.
 * - The carry 'c' is updated based on the carry generated during the addition
 *   operation, and it can be used for subsequent additions.
 */
static void __adc(bi_uword* z, bi_uword* c, const bi_uword* x, const bi_uword* y) 
{
    bi_uword n_c = 0; // n_c : next carry

    // Calculate x + y mod 2^(WORDSIZE*8)
    *z = (*x) + (*y);

    // Check if there is a carry
    if (*z < *x)
        n_c = 1;

    // Calculate x + y + c mod 2^(WORDSIZE*8)
    *z += (*c);

    // Check if there is a next carry
    if (*z < *c)
        n_c += 1;

    // Update the carry for the next addition
    *c = n_c;
}

/**
 * @brief Perform unsigned binary addition (bi_uadd) of two big integers.
 * 
 * This function adds two unsigned big integers 'x' and 'y' and stores the result
 * in 'z'. The addition is performed without considering the sign of the operands.
 * The carry generated during the addition is propagated to the next word as needed.
 * The result 'z' is stored as a new big integer, and any leading zeros in 'z' and 'y'
 * are removed to refine the result.
 * 
 * @param z Pointer to a bi structure where the result of the addition will be stored.
 * @param x Pointer to a bi structure representing the first unsigned operand 'x'.
 * @param y Pointer to a bi structure representing the second unsigned operand 'y'.
 * 
 * @note
 * - The addition is performed word by word, starting from the least significant word,
 *   and any carry generated during the addition is propagated to the next word.
 * - Memory may be reallocated for 'y' to match the dmax (maximum number of digits)
 *   of 'x' if they have different dmax values.
 * - The result 'z' is created as a new big integer and any leading zeros in 'z' and 'y'
 *   are removed (refined) to obtain the final result.
 * - The function assumes that both 'x' and 'y' are non-null and have already been
 *   initialized.
 */
static void bi_uadd(bi** z, const bi* x, bi* y)
{
    bi_uword c = 0; // Initialize carry
    bi* sum = NULL; // Temporary storage for the result

    // Check if 'x' and 'y' have different dmax values
    if (y->dmax != x->dmax) 
    {
        // Reallocate memory for 'y's array to match 'x's dmax
        y->a = (bi_uword*)realloc(y->a, x->dmax * sizeof(bi_uword));
        y->dmax = x->dmax;
    }

    // Create a new big integer for the sum
    bi_new(&sum, x->dmax + 1);

    // Perform binary addition (__adc) word by word
    for (int j = 0; j < x->dmax; j++)
        __adc(&(sum->a[j]), &c, &(x->a[j]), &(y->a[j]));

    // Check if there is a carry left
    sum->a[sum->dmax - 1] = c;

    // Refine the result 'y' to remove leading zeros
    bi_refine(y);

    // Refine the result 'z' to remove leading zeros
    bi_refine(sum);

    // Copy the sum to the result 'z'
    bi_cpy(z, sum);

    // Delete the temporary storage for the sum
    bi_delete(&sum);
}

/**
 * @brief Perform binary addition (bi_add) of two big integers.
 * 
 * This function adds two big integers 'x' and 'y' and stores the result
 * in 'z'. The addition takes into account the signs of the operands and
 * performs the appropriate addition or subtraction. The result 'z' is
 * stored as a new big integer, and any leading zeros in 'z' are removed
 * to refine the result.
 * 
 * @param z Pointer to a bi structure where the result of the addition will be stored.
 * @param x Pointer to a bi structure representing the first operand 'x'.
 * @param y Pointer to a bi structure representing the second operand 'y'.
 * 
 * @note
 * - The function checks the signs of 'x' and 'y' and performs addition or
 *   subtraction accordingly.
 * - If 'x' and 'y' have different dmax values, 'y' may be reallocated to match
 *   the dmax of 'x'.
 * - Special cases are handled:
 *   - If 'x' is equal to zero, 'y' is copied to 'z'.
 *   - If 'y' is equal to zero, 'x' is copied to 'z'.
 *   - If 'x' is positive and 'y' is negative, 'z' will contain the result of
 *     subtracting the absolute value of 'y' from 'x'.
 *   - If 'x' is negative and 'y' is positive, 'z' will contain the result of
 *     subtracting the absolute value of 'x' from 'y'.
 * - The result 'z' is refined to remove leading zeros.
 */
void bi_add(bi** z, bi* x, bi* y) 
{
   // Special case: If 'x' is equal to 0, copy 'y' to 'z'
    if (bi_is_zero(x))
    {
        bi_cpy(z, y);
        return;
    }

    // Special case: If 'y' is equal to 0, copy 'x' to 'z'
    if (bi_is_zero(y))
    {
        bi_cpy(z, x);
        return;
    }
   if(x->sign == POSITIVE && y->sign == POSITIVE)
   {
      if (x->dmax >= y->dmax)
      {
         bi_uadd(z, x, y);
         return;
      }
      else
      {
         bi_uadd(z, y, x);
         return;
      }
   }
   else if(x->sign == NEGATIVE && y->sign == NEGATIVE)
   {
      if (x->dmax >= y->dmax)
      {
         bi_uadd(z, x, y);
         return;
      }
      else
      {
         bi_uadd(z, y, x);
         return;
      }
   }
      
   // Subtract |y| from 'x' if 'x' is positive and 'y' is negative
    else if (x->sign == POSITIVE && y->sign == NEGATIVE) 
    {
      y->sign = POSITIVE;
        bi_sub(z, x, y);
        return;
    }

    // Subtract |x| from 'y' if 'x' is negative and 'y' is positive
    else if (x->sign == NEGATIVE && y->sign == POSITIVE) 
    {
      x->sign = POSITIVE;
        bi_sub(z, y, x);
        return;
    }
   
}